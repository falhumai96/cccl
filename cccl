#!/bin/bash

# cccl
# Wrapper around MS's cl.exe to make it act more like Unix cc
#
# Copyright (C) 2000-2022 by contributors listed in the AUTHORS file.
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.


usage()
{
    cat <<EOF
Usage: cccl [--cccl-link] [--cccl-muffle] [--cccl-verbose] [--help] [--version]
       [OPTIONS]

cccl is a wrapper around Microsoft's cl.exe compiler.  It translates parameters
given by [OPTIONS] that Unix cc understands into parameters that cl understands.
EOF
}

case $MACHTYPE in
    *-msys)
        slash="-"
        ;;
    *)
        slash="/"
        ;;
esac

# prog specifies the program that should be run cl.exe
prog=cl
# opts specifies the command line to pass to the MSVC program
clopt=("${slash}nologo")
linkopt=("${slash}link")
debug=
# gotparam is 0 if we didn't ever see a param, in which case we show usage()
gotparam=
muffle=
verbose=
shared_index=-1
script_dir="$( cd -- "$( dirname -- "${BASH_SOURCE[0]}" )" &> /dev/null && pwd )"
libraries=""
print_search_dirs=false

# Set the "winpath" binary to convert Windows paths to Unix paths
winpath_bin="$CCCL_WINPATH_BIN" # "CCCL_WINPATH_BIN" must have the same format, e.g., as "cygpath"
if [ -z "$winpath_bin" ]; then
    # Guess the "winpath" binary
    # Record the original "IFS"
    if ! [ -z "$IFS" ]; then
        originalIFS="$IFS"
    fi
    IFS=" "
    guess_winpath_bins_str="cygpath wslpath winepath" # For Cygwin/MSYS2 and native Windows, WSL and native Windows,
                                                      # and Linux and Wine, respectfully
    read -ra guess_winpath_bins <<< "$guess_winpath_bins_str"
    for guess_winpath_bin in ${guess_winpath_bins[@]}; do
        winpath_bin="$(which $guess_winpath_bin)"
        if ! [ -z "$winpath_bin" ]; then
            break
        fi
    done
    # Reset the "IFS"
    if ! [ -z "$originalIFS" ]; then
        IFS="$originalIFS"
    else
        unset IFS
    fi
    if [ -z "$winpath_bin" ]; then
        echo "Cannot guess \"winpath\" binary to convert Windows paths to Unix paths and back \
to Windows paths. You must set \"CCCL_WINPATH_BIN\" environment variable with a format similar \
to \"cygpath\", \"wslpath\", or \"winepath\"."
        exit 1
    fi
fi

# Set the "python_bin" binary to help get Windows paths' prefixes
python_bin="$CCCL_PYTHON_BIN" # "CCCL_PYTHON_BIN" must have "pathlib" installed (installed by default in Python 3)
if [ -z "$python_bin" ]; then
    # Guess the "python" binary
    # Record the original "IFS"
    if ! [ -z "$IFS" ]; then
        originalIFS="$IFS"
    fi
    IFS=" "
    guess_python_bins_str="python3 python2 python"
    read -ra guess_python_bins <<< "$guess_python_bins_str"
    for guess_python_bin in ${guess_python_bins[@]}; do
        python_bin="$(which $guess_python_bin)"
        if ! [ -z "$python_bin" ]; then
            break
        fi
    done
    # Reset the "IFS"
    if ! [ -z "$originalIFS" ]; then
        IFS="$originalIFS"
    else
        unset IFS
    fi
    if [ -z "$python_bin" ]; then
        echo "Cannot guess \"python\" binary. You must set \"CCCL_PYTHON_BIN\" environment \
variable with a python binary path (or retrieved from \"PATH\" environment variable) to \
a Python installation with \"pathlib\" module installed."
        exit 1
    fi
fi

processargs()
{
### Run through every option and convert it to the proper MS one
while test $# -gt 0; do
    case "$1" in
    -D*) optarg= ;;
    -*=*) optarg=`echo "$1" | sed 's/[-_a-zA-Z0-9]*=//'` ;;
    *) optarg= ;;
    esac
    gotparam=1

    case "$1" in
    --help)
        usage
        exit 0
        ;;

    --cccl-link)
        # One single option for the linker
        shift
        case "$1" in
        /*)
            linkopt+=("${slash}${1:1}")
            ;;

        *)
            linkopt+=("$1")
            ;;
        esac
        ;;

    --cccl-muffle)
        # Remove the unnecessary junk that the compiler outputs to stdout
        muffle=1
        ;;

    --cccl-verbose)
        verbose=1
        ;;

    --version)
        cat <<EOF
cccl 1.3
EOF
        exit 0;
        ;;

    -ansi)
        clopt+=("${slash}Za")
        ;;

    -c)
        # -c (compile only) is actually the same, but for clarity...
        clopt+=("${slash}c")
        ;;

    -g[0-9] | -g)
        # cl only supports one debugging level
        clopt+=("${slash}Zi")
        debug=1
        ;;

    -O0)
        clopt+=("${slash}Ot")
        ;;

    -O2)
        clopt+=("${slash}O2")
        ;;

    -print-search-dirs | /print-search-dirs)
        # Set "print_search_dirs" to print later
        print_search_dirs=true
        ;;

    -L | -L*)
        if [ "$1" = "-L" ]; then
            shift
            libpath="$(echo "$1")"
        else
            libpath="$(echo "$1" | sed 's/-L//')"
        fi

        # Convert the path to absolute path in Unix
        libpath="$(readlink -m $libpath)"

        # Convert the Unix path to Windows path and send it to the compiler arguments
        linkopt+=("${slash}LIBPATH:$($winpath_bin -w $libpath)")

        if [ -z "$libraries" ]; then
            libraries="$libpath"
        else
            libraries="$libpath:$libraries"
        fi
        ;;

    -link | /link)
        # Libtool compatibility which is trying to pass linker options to cl
        # Same behaviour as cl - all options after -link are linker options
        shift
        while test $# -gt 0; do
            case "$1" in
            -*)
                linkopt+=("${slash}${1:1}")
                ;;

            /*)
                linkopt+=("${slash}${1:1}")
                ;;

            *)
                linkopt+=("$1")
                ;;
            esac
            shift
        done
        ;;


    # TODO: Add support for "-l:<full_lib_name>" pattern, where "full_lib_name" is the
    #       full library name (e.g. instead of "-lLLVM" there should be a pattern for "-l:LLVM.lib" as well).
    -l*)
        lib=`echo "$1" | sed 's/-l//'`
        lib="$lib.lib"
        clopt+=("$lib")
        ;;

    -m386)
        clopt+=("${slash}G3")
        ;;

    -m486)
        clopt+=("${slash}G4")
        ;;

    -mpentium)
        clopt+=("${slash}G5")
        ;;

    -mpentiumpro)
        clopt+=("${slash}G6")
        ;;

    -o)
        # specifying output file, is it an object or an executable
        shift
        case "$1" in
        *.o | *.obj)
            clopt+=("${slash}Fo$1")
            ;;

        *.exe | *.dll | *.pyd)
            clopt+=("${slash}Fe$1")
            ;;
        esac
        ;;

    -std=*)
        clopt+=("${slash}std:${1:5}")
        case "$1" in
        -std=c++*)
            clopt+=("${slash}Zc:__cplusplus")
            ;;
        esac
        ;;

    -pedantic)
        #ignore pedantic
        ;;

    -Wl,*)
        IFS=',' read -ra linkopt2 <<< "$(echo $1 | sed 's/-Wl,//')"
        for linkarg in ${linkopt2[@]}; do
            linkopt+=("${linkarg}")
        done
        ;;

    -W*)
        #ignore warnings
        ;;

    -fno-strict-aliasing*)
        #ignore aliasing
        ;;

    -isystem | -I)
        shift

        # Convert the path to absolute path in Unix
        path="$(readlink -m $1)"

        # Convert the Unix path to Windows path and send it to the compiler arguments
        clopt+=("${slash}I$($winpath_bin -w $path)")
        ;;

    -rpath)
        #ignore this arg and the path
        shift
        ;;

    -MT)
        exit 0
        ;;

    -mno-cygwin)
        ;;

    -shared | -dll)
        shared_index=${#clopt[@]}
        clopt+=("${slash}LD")
        ;;

    -*)
        # Remaining '-' options are passed to the compiler
        if test x$optarg != x ; then
            clopt+=("${slash}${1:1}=$optarg")
        else
            clopt+=("${slash}${1:1}")
        fi
        ;;

    *.cc | *.cxx | *.C)
        # C++ source file with non .cpp extension, make sure cl understand 
        # that it is C++
        clopt+=("${slash}Tp$1")
        ;;

    /*)
        # All '/' options are assumed to be for cl and are passed through
        clopt+=("${slash}${1:1}")
        ;;

    *)
        clopt+=("$1")
        ;;

    esac
    shift
done
}

# Whitespace in paths is dealt with by setting IFS and using bash arrays
# Except additional arguments in CCCL_OPTIONS need to be space separated
processargs $CCCL_OPTIONS
IFS=""
processargs $@

if test $shared_index -ge 0 -a -n "$debug"; then
    clopt[$shared_index]="${slash}LDd"
fi

if test x$gotparam = x ; then
    usage
    exit 1
fi

if test ${#linkopt[@]} -eq 1 ; then
    linkopt=()
fi

if test x$V = x1 ; then
    verbose=1
fi

if test -n "$verbose" ; then
  echo -n "$prog"
  for opt in "${clopt[@]}" ; do
    echo -n " \"$opt\""
  done
  for opt in "${linkopt[@]}" ; do
    echo -n " \"$opt\""
  done
  echo ""
fi

# Process "print-search-dirs" and exit gracefully
if $print_search_dirs; then
    # Print "install"
    echo "install: $script_dir"

    # TODO: Implement printing "programs" for the MSVC toolchain. Not sure which bin dirs to print, nor if it is ever needed for
    # the MSVC toolchain

    # To get the Windows path prefix from the Windows path, using Python's "pathlib" module
    get_windows_prefix_source="$(printf "%s\n" \
                                "import sys" \
                                "import pathlib" \
                                "windows_pure_path = pathlib.PureWindowsPath(sys.argv[1])" \
                                "drive = windows_pure_path.drive + \"\\\\\" if windows_pure_path.drive else \".\\\\\"" \
                                "print(drive)")"

    # To replace the long version of the Windows prefix in Unix form with the short version, in the long Unix path.
    # In other words, generate a short version of the full Unix path.
    replace_source="$(printf "%s\n" \
                      "import sys" \
                      "import pathlib" \
                      "libpath_unix_long_parts = list(pathlib.PurePosixPath(sys.argv[1]).parts)" \
                      "libpath_unix_long_prefix_parts = list(pathlib.PurePosixPath(sys.argv[2]).parts)" \
                      "libpath_unix_short_prefix_parts = list(pathlib.PurePosixPath(sys.argv[3]).parts)" \
                      "new_path = pathlib.PurePosixPath(\"\")" \
                      "new_path_parts = libpath_unix_short_prefix_parts + libpath_unix_long_parts[len(libpath_unix_long_prefix_parts):]" \
                      "for part in new_path_parts:" \
                      "    new_path = new_path.joinpath(part)" \
                      "print(new_path)")"

    # Set the global libraries
    global_libraries=""

    # Record the original "IFS"
    if ! [ -z "$IFS" ]; then
        originalIFS="$IFS"
    fi
    IFS=";"
    read -ra global_libraries_windows <<< "$LIB"
    for libpath in ${global_libraries_windows[@]}; do
        libpath="$($winpath_bin -w $($winpath_bin -u $libpath))" # Get the full path of the Windows path, by converting it to Unix and back to Windows.
        libpath_windows_prefix="$($python_bin -c $get_windows_prefix_source $libpath)"
        libpath_unix_long_prefix="$($winpath_bin -u $libpath_windows_prefix)"
        libpath_unix_short_prefix="$(readlink -m $libpath_unix_long_prefix)"
        libpath_unix_long="$($winpath_bin -u $libpath)"

        # Replace Unix version of the long Windows path prefix with the Unix version of the short Windows path prefix of the long Unix version of the Windows library path.
        # The reason for replacing is that Unix usually do not escape ":" in paths strings (e.g. in "PATH" environment variable or in "libtool" when reading "print-search-dirs"'s "libraries" output),
        # which is, for example, what Windows drives have (e.g. "c:\" that gets converted to "$WINEPREFIX/dosdevices/c:/" in "winepath" command). Instead of replacing the whole Unix path
        # with a shorter version, using "realpath" for example, and losing the original path (possibly a symlink directory), only follow the real path of the Windows prefix and keep the rest of the path intact.
        unix_global_library_path="$($python_bin -c "$replace_source" $libpath_unix_long $libpath_unix_long_prefix $libpath_unix_short_prefix)"

        if [ -z "$global_libraries" ]; then
            global_libraries="$unix_global_library_path"
        else
            global_libraries="$global_libraries:$unix_global_library_path"
        fi
    done
    # Reset the "IFS"
    if ! [ -z "$originalIFS" ]; then
        IFS="$originalIFS"
    else
        unset IFS
    fi

    # Update "libraries" with the global libraries
    if [ -z "$libraries" ]; then
        libraries="$global_libraries"
    else
        # Global libraries are set after the ones defined by the command line argument "-L", as the latter takes
        # precedence
        libraries="$libraries:$global_libraries"
    fi

    # Print "libraries"
    echo "libraries: =$libraries"

    exit 0
fi

if test -z "$muffle" ; then
    exec $prog ${clopt[@]} ${linkopt[@]}
else
  # tr needed below for $ in regex to work (simple alternative to dos2unix)
    exec $prog ${clopt[@]} ${linkopt[@]} | tr -d '\r' | grep -v -e "\.cpp$" -e "\.cxx$" -e "\.cc$" -e "\.C$" -e "\.c$" -e "^   Creating library" -e "^Generating Code"
    exit ${PIPESTATUS[0]}
fi
